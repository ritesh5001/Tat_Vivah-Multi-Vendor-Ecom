// Prisma Schema for AUTH MICROSERVICE
// This service handles ONLY: Authentication, Authorization, Token issuance, Sessions
// Database: PostgreSQL (Neon) - ISOLATED from other services

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// ENUMS
// ============================================================================

enum Role {
  USER
  SELLER
  ADMIN
  QA_ADMIN
  SUPER_ADMIN
}

enum UserStatus {
  PENDING
  ACTIVE
  SUSPENDED
}

// ============================================================================
// CORE TABLES (AUTH SERVICE ONLY)
// ============================================================================

/// Core user table for authentication
/// Minimal data - profiles are managed by their respective microservices
/// Note: email and phone are optional, but at least one must exist (enforced in application)
model User {
  id              String     @id @default(uuid())
  email           String?    @unique
  phone           String?    @unique
  passwordHash    String     @map("password_hash")
  role            Role
  status          UserStatus
  isEmailVerified Boolean    @default(false) @map("is_email_verified")
  isPhoneVerified Boolean    @default(false) @map("is_phone_verified")
  createdAt       DateTime   @default(now()) @map("created_at")
  updatedAt       DateTime   @updatedAt @map("updated_at")

  // Relations within AUTH service only
  loginSessions     LoginSession[]
  adminProfile      AdminProfile?
  qaAdminProfile    QaAdminProfile?
  superAdminProfile SuperAdminProfile?

  // Product relations (Seller only)
  products Product[]

  // Payment & Settlement relations
  payments    Payment[]
  settlements SellerSettlement[]

  @@map("users")
}

/// Tracks active login sessions for refresh token management
/// Each session represents a device/browser where user is logged in
model LoginSession {
  id           String   @id @default(cuid())
  userId       String   @map("user_id")
  refreshToken String   @map("refresh_token")
  userAgent    String?  @map("user_agent")
  ipAddress    String?  @map("ip_address")
  expiresAt    DateTime @map("expires_at")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([refreshToken])
  @@map("login_sessions")
}

// ============================================================================
// ADMIN PROFILE TABLES (AUTH SERVICE MANAGES THESE)
// ============================================================================

/// Profile data for admin users
/// Managed by AUTH service since ADMIN creation is internal
model AdminProfile {
  id          String   @id @default(cuid())
  userId      String   @unique @map("user_id")
  firstName   String   @map("first_name")
  lastName    String   @map("last_name")
  phone       String?
  department  String?
  designation String?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("admin_profiles")
}

/// Profile data for QA admin users
/// Managed by AUTH service since QA_ADMIN creation is internal
model QaAdminProfile {
  id             String   @id @default(cuid())
  userId         String   @unique @map("user_id")
  firstName      String   @map("first_name")
  lastName       String   @map("last_name")
  phone          String?
  specialization String?
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("qa_admin_profiles")
}

/// Profile data for super admin users
/// Managed by AUTH service - SUPER_ADMIN created via DB only
model SuperAdminProfile {
  id        String   @id @default(cuid())
  userId    String   @unique @map("user_id")
  firstName String   @map("first_name")
  lastName  String   @map("last_name")
  phone     String?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("super_admin_profiles")
}

// ============================================================================
// PRODUCT & CATALOG DOMAIN
// ============================================================================

/// Product categories for organizing products
model Category {
  id        String    @id @default(cuid())
  name      String
  slug      String    @unique
  isActive  Boolean   @default(true) @map("is_active")
  createdAt DateTime  @default(now()) @map("created_at")

  // Relations
  products Product[]

  @@map("categories")
}

/// Products owned by sellers
model Product {
  id          String           @id @default(cuid())
  sellerId    String           @map("seller_id")
  categoryId  String           @map("category_id")
  title       String
  description String?
  images      String[]         @default([]) @map("images")
  isPublished Boolean          @default(false) @map("is_published")
  createdAt   DateTime         @default(now()) @map("created_at")
  updatedAt   DateTime         @updatedAt @map("updated_at")

  // Relations
  seller   User             @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  category Category         @relation(fields: [categoryId], references: [id])
  variants ProductVariant[]

  @@index([sellerId])
  @@index([categoryId])
  @@map("products")
}

/// Product variants with pricing (e.g., size, color)
model ProductVariant {
  id             String    @id @default(cuid())
  productId      String    @map("product_id")
  sku            String    @unique
  price          Float
  compareAtPrice Float?    @map("compare_at_price")
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")

  // Relations
  product   Product    @relation(fields: [productId], references: [id], onDelete: Cascade)
  inventory Inventory?

  @@index([productId])
  @@map("product_variants")
}

/// Inventory tracking per variant (1:1 with ProductVariant)
model Inventory {
  variantId String         @id @map("variant_id")
  stock     Int            @default(0)
  updatedAt DateTime       @updatedAt @map("updated_at")

  // Relations
  variant ProductVariant @relation(fields: [variantId], references: [id], onDelete: Cascade)

  @@map("inventory")
}

// ============================================================================
// CART & ORDERS DOMAIN
// ============================================================================

enum OrderStatus {
  PLACED
  CONFIRMED
  CANCELLED
}

enum InventoryMovementType {
  RESERVE
  RELEASE
  DEDUCT
}

/// Shopping cart for buyers (one per user)
model Cart {
  id        String     @id @default(cuid())
  userId    String     @unique @map("user_id")
  updatedAt DateTime   @updatedAt @map("updated_at")

  // Relations
  items CartItem[]

  @@map("carts")
}

/// Items in shopping cart with price snapshot
model CartItem {
  id            String   @id @default(cuid())
  cartId        String   @map("cart_id")
  productId     String   @map("product_id")
  variantId     String   @map("variant_id")
  quantity      Int
  priceSnapshot Float    @map("price_snapshot")
  createdAt     DateTime @default(now()) @map("created_at")

  // Relations
  cart Cart @relation(fields: [cartId], references: [id], onDelete: Cascade)

  @@unique([cartId, variantId])
  @@index([cartId])
  @@map("cart_items")
}

/// Orders placed by buyers
model Order {
  id          String      @id @default(cuid())
  userId      String      @map("user_id")
  status      OrderStatus @default(PLACED)
  totalAmount Float       @map("total_amount")
  createdAt   DateTime    @default(now()) @map("created_at")

  // Relations
  items     OrderItem[]
  movements InventoryMovement[]
  payment   Payment?

  @@index([userId])
  @@map("orders")
}

/// Individual items in an order with seller reference
model OrderItem {
  id            String @id @default(cuid())
  orderId       String @map("order_id")
  sellerId      String @map("seller_id")
  productId     String @map("product_id")
  variantId     String @map("variant_id")
  quantity      Int
  priceSnapshot Float  @map("price_snapshot")

  // Relations
  order      Order             @relation(fields: [orderId], references: [id], onDelete: Cascade)
  settlement SellerSettlement?

  @@index([orderId])
  @@index([sellerId])
  @@map("order_items")
}

/// Auditable inventory movements for stock changes
model InventoryMovement {
  id        String                @id @default(cuid())
  variantId String                @map("variant_id")
  orderId   String                @map("order_id")
  quantity  Int
  type      InventoryMovementType
  createdAt DateTime              @default(now()) @map("created_at")

  // Relations
  order Order @relation(fields: [orderId], references: [id])

  @@index([variantId])
  @@index([orderId])
  @@map("inventory_movements")
}


// ============================================================================
// PAYMENTS & SETTLEMENT DOMAIN
// ============================================================================

enum PaymentStatus {
  INITIATED
  SUCCESS
  FAILED
  REFUNDED
}

enum PaymentProvider {
  RAZORPAY
  STRIPE
  MOCK
}

enum PaymentEventType {
  INITIATED
  SUCCESS
  FAILED
  WEBHOOK
}

enum SettlementStatus {
  PENDING
  PAID
}

/// Payments linked to Orders (1:1)
model Payment {
  id                String          @id @default(cuid())
  orderId           String          @unique @map("order_id")
  userId            String          @map("user_id")
  amount            Float
  currency          String          @default("INR")
  status            PaymentStatus   @default(INITIATED)
  provider          PaymentProvider
  providerPaymentId String?         @map("provider_payment_id")
  createdAt         DateTime        @default(now()) @map("created_at")
  updatedAt         DateTime        @updatedAt @map("updated_at")

  // Relations
  order  Order          @relation(fields: [orderId], references: [id])
  user   User           @relation(fields: [userId], references: [id])
  events PaymentEvent[]

  @@index([userId])
  @@index([providerPaymentId])
  @@map("payments")
}

/// Immutable ledger of payment lifecycle events
model PaymentEvent {
  id        String           @id @default(cuid())
  paymentId String           @map("payment_id")
  type      PaymentEventType
  payload   Json?
  createdAt DateTime         @default(now()) @map("created_at")

  // Relations
  payment Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  @@index([paymentId])
  @@map("payment_events")
}

/// Seller settlements for order items (Foundation)
model SellerSettlement {
  id          String           @id @default(cuid())
  sellerId    String           @map("seller_id")
  orderItemId String           @unique @map("order_item_id")
  amount      Float
  status      SettlementStatus @default(PENDING)
  createdAt   DateTime         @default(now()) @map("created_at")

  // Relations
  seller    User      @relation(fields: [sellerId], references: [id])
  orderItem OrderItem @relation(fields: [orderItemId], references: [id])

  @@index([sellerId])
  @@map("seller_settlements")
}
